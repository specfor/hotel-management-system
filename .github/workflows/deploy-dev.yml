# Development and Staging Deployment Pipeline
name: Deploy to Dev/Staging

on:
  push:
    branches: [develop]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: hotel-management-system

jobs:
  # Test Backend
  test-backend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: backend/package-lock.json

      - name: Install backend dependencies
        run: |
          cd backend
          npm ci

      - name: Run backend linting
        run: |
          cd backend
          npm run lint

      - name: Run backend type check
        run: |
          cd backend
          npm run type-check

      - name: Run backend tests
        run: |
          cd backend
          npm test

  # Test Frontend
  test-frontend:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        run: |
          cd frontend
          npm ci

      - name: Run frontend linting
        run: |
          cd frontend
          npm run lint || true  # Allow to continue if no lint script

      - name: Build frontend
        run: |
          cd frontend
          npm run build

      - name: Run frontend tests (if available)
        run: |
          cd frontend
          npm test || true  # Allow to continue if no test script

  # Validate Infrastructure
  validate-terraform:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Format Check
        run: |
          cd infrastructure
          terraform fmt -check

      - name: Terraform Init
        run: |
          cd infrastructure
          terraform init

      - name: Terraform Validate
        run: |
          cd infrastructure
          terraform validate

      - name: Terraform Plan
        run: |
          cd infrastructure
          terraform plan \
            -var="project_name=${{ env.PROJECT_NAME }}" \
            -var="environment=${{ github.event.inputs.environment || 'dev' }}" \
            -var="aws_region=${{ env.AWS_REGION }}"

  # Deploy to Development/Staging
  deploy-dev-staging:
    needs: [test-backend, test-frontend, validate-terraform]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/frontend-setup' || github.ref == 'refs/heads/develop' || github.event.inputs.environment != ''
    environment: ${{ github.event.inputs.environment || (github.ref == 'refs/heads/main' && 'staging') || 'dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Determine Environment
        id: env
        run: |
          if [ "${{ github.event.inputs.environment }}" != "" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            ENV="staging"
          else
            ENV="dev"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "Deploying to environment: $ENV"

      - name: Deploy Infrastructure
        id: deploy-infra
        run: |
          cd infrastructure

          # Create terraform.tfvars for deployment
          cat > terraform.tfvars << EOF
          project_name = "${{ env.PROJECT_NAME }}"
          environment  = "${{ steps.env.outputs.environment }}"
          aws_region   = "${{ env.AWS_REGION }}"

          # Dev/Staging optimized settings
          node_instance_types   = ["t3.micro"]
          node_desired_capacity = 1
          node_max_capacity     = 2
          node_min_capacity     = 1

          # Use spot instances for cost savings in dev/staging
          node_capacity_type = "SPOT"

          # Minimal database for dev/staging
          db_allocated_storage = 5

          tags = {
            Environment = "${{ steps.env.outputs.environment }}"
            Project     = "${{ env.PROJECT_NAME }}"
            ManagedBy   = "github-actions"
            Branch      = "${{ github.ref_name }}"
            CommitSha   = "${{ github.sha }}"
          }
          EOF

          terraform init
          terraform apply -auto-approve

          # Export outputs for next steps
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
          echo "cluster_name=$(terraform output -raw cluster_id)" >> $GITHUB_OUTPUT
          echo "s3_bucket_name=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT
          echo "cloudfront_distribution_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ steps.deploy-infra.outputs.cluster_name }}

      - name: Build and Push Backend Image
        run: |
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.deploy-infra.outputs.ecr_repository_url }}

          # Build and push backend
          cd backend
          docker build -t ${{ steps.deploy-infra.outputs.ecr_repository_url }}:latest .
          docker build -t ${{ steps.deploy-infra.outputs.ecr_repository_url }}:${{ github.sha }} .

          docker push ${{ steps.deploy-infra.outputs.ecr_repository_url }}:latest
          docker push ${{ steps.deploy-infra.outputs.ecr_repository_url }}:${{ github.sha }}

      - name: Deploy Backend
        run: |
          # Wait for backend deployment to be ready
          kubectl rollout status deployment/backend -n ${{ env.PROJECT_NAME }}-app --timeout=600s || true

          # Restart deployment to use new image
          kubectl rollout restart deployment/backend -n ${{ env.PROJECT_NAME }}-app

      - name: Build and Deploy Frontend
        run: |
          cd frontend

          # Install dependencies and build
          npm ci
          npm run build

          # Deploy to S3
          aws s3 sync dist/ s3://${{ steps.deploy-infra.outputs.s3_bucket_name }}/ --delete \
            --cache-control "public, max-age=31536000" --exclude "*.html"

          aws s3 sync dist/ s3://${{ steps.deploy-infra.outputs.s3_bucket_name }}/ --delete \
            --cache-control "public, max-age=0, must-revalidate" --include "*.html"

          # Invalidate CloudFront cache
          aws cloudfront create-invalidation \
            --distribution-id ${{ steps.deploy-infra.outputs.cloudfront_distribution_id }} \
            --paths "/*"

      - name: Run Database Migrations
        run: |
          # Get backend pod
          BACKEND_POD=$(kubectl get pods -n ${{ env.PROJECT_NAME }}-app -l app=backend -o jsonpath='{.items[0].metadata.name}' || echo "")

          if [ -n "$BACKEND_POD" ]; then
            echo "Running migrations on pod: $BACKEND_POD"
            kubectl exec -n ${{ env.PROJECT_NAME }}-app $BACKEND_POD -- npm run migrate || echo "Migration failed or not available"
          else
            echo "No backend pods found, skipping migrations"
          fi

      - name: Health Check
        run: |
          # Wait for backend to be healthy
          sleep 30

          # Get the application URL from terraform outputs
          cd infrastructure
          FRONTEND_URL=$(terraform output -raw frontend_url)
          API_URL=$(terraform output -raw api_endpoint)

          echo "Frontend URL: $FRONTEND_URL"
          echo "API URL: $API_URL"

          # Simple health check (will be available after DNS propagation)
          echo "Deployment completed! Check the following URLs after DNS propagation:"
          echo "Frontend: $FRONTEND_URL"
          echo "API: $API_URL/health"

      - name: Deployment Summary
        run: |
          cd infrastructure
          echo "## ðŸš€ ${{ steps.env.outputs.environment }} Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.env.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Frontend URL**: $(terraform output -raw frontend_url)" >> $GITHUB_STEP_SUMMARY
          echo "- **API Endpoint**: $(terraform output -raw api_endpoint)" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: $(terraform output -raw cluster_id)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ’° **Cost Information**:" >> $GITHUB_STEP_SUMMARY
          echo "- Using t3.micro spot instances for cost optimization" >> $GITHUB_STEP_SUMMARY
          echo "- Estimated monthly cost: ~\$110" >> $GITHUB_STEP_SUMMARY
